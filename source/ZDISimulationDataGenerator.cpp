#include "ZDISimulationDataGenerator.h"
#include "ZDIAnalyzerSettings.h"

#include <AnalyzerHelpers.h>

// the simulated data is generated by an MPU clocked at 16MHz, changing ZCL every 3 cycles
#define MPU_CLOCK  0.0000000625

struct SimulationData
{
    U8 reg;
    U8 value;
};

SimulationData simul_data[] = {
    { 0x01, 0x80 }, { 0x00, 0x00 },
};

ZDISimulationDataGenerator::ZDISimulationDataGenerator()
{
}

ZDISimulationDataGenerator::~ZDISimulationDataGenerator()
{
}

void ZDISimulationDataGenerator::Initialize( U32 simulation_sample_rate, ZDIAnalyzerSettings* settings )
{
	mSimulationSampleRateHz = simulation_sample_rate;
	mSettings = settings;

	mCurrentSample = 0;

	mClockGenerator.Init( simulation_sample_rate / 10, simulation_sample_rate );

	mZCL = mZDISimulationChannels.Add( settings->mZCL, mSimulationSampleRateHz, BIT_HIGH );
	mZDA = mZDISimulationChannels.Add( settings->mZDA, mSimulationSampleRateHz, BIT_HIGH );
}

U32 ZDISimulationDataGenerator::GenerateSimulationData( U64 largest_sample_requested, U32 sample_rate, SimulationChannelDescriptor** simulation_channels )
{
	U64 adjusted_largest_sample_requested = AnalyzerHelpers::AdjustSimulationTargetSample( largest_sample_requested, sample_rate, mSimulationSampleRateHz );

	while( mZCL->GetCurrentSampleNumber() < adjusted_largest_sample_requested )
	{
		// generate the bits for the transaction
		OutputTransaction( simul_data[ mCurrentSample ] );

		mCurrentSample++;
		if ( mCurrentSample == std::size( simul_data ) )
			mCurrentSample = 0;

	}

	*simulation_channels = mZDISimulationChannels.GetArray();

	return mZDISimulationChannels.GetCount();
}

void ZDISimulationDataGenerator::OutputTransaction( const SimulationData &data )
{
    mZCL->TransitionIfNeeded( BIT_HIGH );
    mZDA->TransitionIfNeeded( BIT_HIGH );

    AdvanceAllBySec( MPU_CLOCK * 10 );

    mZDA->TransitionIfNeeded( BIT_LOW );

    AdvanceAllBySec( MPU_CLOCK * 2 );

    /* Send the register (plus read/write bit) data */
    for (int bit = 7; bit >= 0; bit--) {

        // clock goes low
        mZCL->Transition();

        AdvanceAllBySec( MPU_CLOCK );

        // set the data bit
        mZDA->TransitionIfNeeded( data.reg & ( 1 << bit ) ? BIT_HIGH : BIT_LOW );

        AdvanceAllBySec( MPU_CLOCK * 2 );

        // clock goes high
        mZCL->Transition();

        AdvanceAllBySec( MPU_CLOCK * 3 );

    }

    // Send the one-bit separator
    mZCL->Transition();
    AdvanceAllBySec( MPU_CLOCK );
    mZDA->TransitionIfNeeded( BIT_LOW );
    AdvanceAllBySec( MPU_CLOCK * 2 );
    mZCL->Transition();
    AdvanceAllBySec( MPU_CLOCK * 3 );

    /* Read/write the register value */
    for (int bit = 7; bit >= 0; bit--) {

        // clock goes low
        mZCL->Transition();

        AdvanceAllBySec( MPU_CLOCK );

        // reads take longer for data to transition
        AdvanceAllBySec( MPU_CLOCK * ( data.reg & 1 ) );

        // set the data bit
        mZDA->TransitionIfNeeded( data.value & ( 1 << bit ) ? BIT_HIGH : BIT_LOW );

        // reads take longer for data to transition
        AdvanceAllBySec( MPU_CLOCK );
        AdvanceAllBySec( MPU_CLOCK * ( ~data.reg & 1 ) );

        // clock goes high
        mZCL->Transition();

        AdvanceAllBySec( MPU_CLOCK * 3 );

    }

    // Send the one-bit separator
    mZCL->Transition();
    AdvanceAllBySec( MPU_CLOCK );
    mZDA->TransitionIfNeeded( BIT_HIGH );
    AdvanceAllBySec( MPU_CLOCK * 2 );
    mZCL->Transition();
    AdvanceAllBySec( MPU_CLOCK * 10 );

}
